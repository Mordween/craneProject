<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>rogidBodies rope</title>
    <link rel="stylesheet" href="../css/examples.css?ver=1.0.0" />
    <script src="../js/examples.js?ver=1.1.1"></script>
    <script src="../lib/enable3d/enable3d.framework.0.25.4.min.Zup.js"></script>
  </head>

  <body>
    <div id="info-text">
      You can move the rope using the <b>directional arrows</b> or the <b>classic keys</b>. <br>
      Left side : Point to point constraint
      Middle : Twist constraint
      Right side : Dof constraint
    </div>
    <script>
      const { Project, Scene3D, PhysicsLoader, THREE, ExtendedObject3D } = ENABLE3D

      class MainScene extends Scene3D {


        async create() {

          const { orbitControls } = await this.warpSpeed()

          this.camera.position.set(-5, -10, 40)
          orbitControls?.target.set(0, 2.5, 0)
          this.camera.lookAt(0, 10, 0)

          // enable physics debugging
          this.physics.debug?.enable()

          // world axis 
          const axesHelper = new THREE.AxesHelper( 5 );
          axesHelper.setColors(new THREE.Color(255, 0, 0), new THREE.Color(0, 255, 0), new THREE.Color(0, 0, 255))    // in order to know which axis is the right axis
          this.scene.add( axesHelper );

          this.ball = this.physics.add.sphere({x:0, y:0, z:0, radius:0.001 })
          this.ball1 = this.ball.clone()
          this.ball2 = this.ball.clone()
          this.brick = this.addBrick({x:0, y:0, z:0}, {x:0, y:0, z:0}, 4)

          this.initInput()

            //   this.rigidRope({x:5, y:5, z:20}, 20)

            this.rigidDOFRope({x:5, y:0, z:20}, 20)
            this.rigidTwistRope({x:0, y:0, z:20}, 20)
            this.rigidP2PRope({x:-5, y:0, z:20}, 20)
         

          const dof = x => {
            this.ball1 = this.physics.add.sphere({
              mass: 1,
              x: x,
              y: 0,
              z: 0,
              radius:0.1,
              collisionFlags: 2,})

            this.ball2 = this.physics.add.sphere({
              mass: 1,
              x: x,
              y: 0,
              z: -1,
              radius:0.1,
              })

              this.ball3 = this.physics.add.sphere({
              mass: 1,
              x: x,
              y: 0,
              z: -2,
              radius:0.1,
              })

            this.physics.add.constraints.dof(this.ball1.body, this.ball2.body, { center: true })
            this.physics.add.constraints.dof(this.ball2.body, this.ball3.body, { center: true })

            // this.box2 = box1 // we rotate this box in update()
          }


          console.log(this)


        }

        update(time) 
        {

          /*** Friction with air ***/ 
          this.brick.body.applyForceX(- 0.05* this.brick.body.velocity.x * 1 * this.physics.physicsWorld.getWorldInfo().air_density )
          this.brick.body.applyForceY(- 0.05* this.brick.body.velocity.y * 1 * this.physics.physicsWorld.getWorldInfo().air_density )
          this.brick.body.applyForceZ(- 0.05* this.brick.body.velocity.z * 1 * this.physics.physicsWorld.getWorldInfo().air_density )

        }

        addBrick = (position = {x: number, y: number, z: number}, rotation = {x: number, y: number, z: number}, scale)=> {
          const brick = this.physics.add.box({
            mass: 10,
            x: position.x,
            y: position.y,
            z: position.z,
            height: 0.22*scale,
            width: 0.105*scale,
            depth: 0.06*scale,
            collisionFlags: 0,
            scale: scale,
          })
          brick.body.setFriction(1)
          brick.body.setDamping(0.5,0.5);
          return brick
        }

        rigidTwistRope(position = {x: number, y: number, z: number}, numberOfPoint)
        {
          this.ball2.length = numberOfPoint;
          this.ball2[0] = this.physics.add.sphere({
          mass: 1,
          x: position.x,
          y: position.y,
          z: position.z,
          radius:0.1,
          collisionFlags: 2,})

            for(let i = 1; i< numberOfPoint; i++)
            {
                this.ball2[i] = this.physics.add.sphere({
                mass: 0.05,
                x: position.x,
                y: position.y,
                z: position.z - 0.2*i,  
                radius:0.1,
                collisionFlags: 0,
              })
              this.constraint = this.physics.add.constraints.coneTwist(this.ball2[i-1].body, this.ball2[i].body, {
              frameA: { x: 0, y: 0, z: -0.2 },
              frameB: { x: 0, y: 0, z: 0.2 }
            })
            }
        }

        rigidDOFRope(position = {x: number, y: number, z: number}, numberOfPoint)
        {
          this.ball1.length = numberOfPoint;
          this.ball1[0] = this.physics.add.sphere({
          mass: 1,
          x: position.x,
          y: position.y,
          z: position.z,
          radius:0.1,
          collisionFlags: 2,})

            for(let i = 1; i< numberOfPoint; i++)
            {
                this.ball1[i] = this.physics.add.sphere({
                mass: 0.05,
                x: position.x,
                y: position.y,
                z: position.z - 0.2*i,  
                radius:0.1,
                collisionFlags: 0,
              })

              this.constraint = this.physics.add.constraints.dof(this.ball1[i-1].body, this.ball1[i].body,  { center: true })
              this.constraint.setLinearLowerLimit(0)
              this.constraint.setLinearUpperLimit(0)

            }
        }

        rigidP2PRope(position = {x: number, y: number, z: number}, numberOfPoint)
        {
          this.ball.length = numberOfPoint;
          this.ball[0] = this.physics.add.sphere({
          mass: 1,
          x: position.x,
          y: position.y,
          z: position.z,
          radius:0.1,
          collisionFlags: 2,})

            for(let i = 1; i< numberOfPoint; i++)
            {
                this.ball[i] = this.physics.add.sphere({
                mass: 0.05,
                x: position.x,
                y: position.y,
                z: position.z - 0.2*i,  
                radius:0.1,
                collisionFlags: 0,
              })
              this.constraint = this.physics.add.constraints.pointToPoint(this.ball[i-1].body, this.ball[i].body, {
              // the offset from the center of each object
              pivotA: { z: 0 },
              pivotB: { z: 0.2  }
              }) 

            }
        }

        rigidRope(position = {x: number, y: number, z: number}, numberOfPoint)
        {
          this.ball.length = numberOfPoint;
          this.ball[0] = this.physics.add.sphere({
          mass: 1,
          x: position.x,
          y: position.y,
          z: position.z,
          radius:0.1,
          collisionFlags: 2,})

            for(let i = 1; i< numberOfPoint; i++)
            {
                this.ball[i] = this.physics.add.sphere({
                mass: 0.05,
                x: position.x,
                y: position.y,
                z: position.z - 0.2*i,  
                radius:0.1,
                collisionFlags: 0,
              })
              // this.constraint = this.physics.add.constraints.pointToPoint(this.ball[i-1].body, this.ball[i].body, {
              // // the offset from the center of each object
              // pivotA: { z: 0 },
              // pivotB: { z: 0.2  }
              // }) 
              // this.constraint = this.physics.add.constraints.dof(this.ball[i-1].body, this.ball[i].body,  { center: true })
              // console.log(this.constraint.getBreakingImpulseThreshold()) // good

              // this.constraint.get_m_setting().set_m_impulseClamp(10000)
              // this.constraint.get_m_setting().set_m_tau(10000)
              // console.log(this.constraint.get_m_setting())
              // this.constraint.setLinearLowerLimit(0)
              // this.constraint.setLinearUpperLimit(0)

              this.constraint = this.physics.add.constraints.coneTwist(this.ball[i-1].body, this.ball[i].body, {
              frameA: { x: 0, y: 0, z: -0.2 },
              frameB: { x: 0, y: 0, z: 0.2 }
            })
              console.log(this.constraint)

            }
        }

        initInput()
        {
          window.addEventListener(
            "keydown",
            (event) => {
              switch (event.code) {
                case "KeyS":
                case "ArrowDown":
                  // Handle "back"
                  this.ball[0].position.y -= 0.1;
                  this.ball[0].body.needUpdate = true;
                  this.ball1[0].position.y -= 0.1;
                  this.ball1[0].body.needUpdate = true;
                  this.ball2[0].position.y -= 0.1;
                  this.ball2[0].body.needUpdate = true;
                  break;
                case "KeyW":
                case "ArrowUp":
                  // Handle "forward"
                  this.ball[0].position.y += 0.1;
                  this.ball[0].body.needUpdate = true;
                  this.ball1[0].position.y += 0.1;
                  this.ball1[0].body.needUpdate = true;
                  this.ball2[0].position.y += 0.1;
                  this.ball2[0].body.needUpdate = true;

                  break;
                case "KeyA":
                case "ArrowLeft":
                  // Handle "turn left"
                  this.ball[0].position.x -= 0.1;
                  this.ball[0].body.needUpdate = true;
                  this.ball1[0].position.x -= 0.1;
                  this.ball1[0].body.needUpdate = true;
                  this.ball2[0].position.x -= 0.1;
                  this.ball2[0].body.needUpdate = true;

                  break;
                case "KeyD":
                case "ArrowRight":
                  // Handle "turn right"
                  this.ball[0].position.x += 0.1;
                  this.ball[0].body.needUpdate = true;
                  this.ball1[0].position.x += 0.1;
                  this.ball1[0].body.needUpdate = true;
                  this.ball2[0].position.x += 0.1;
                  this.ball2[0].body.needUpdate = true;

                  break;

                case "NumpadEnter": 
                this.brick = this.addBrick(
                    {
                      x:this.ball[this.ball.length-1].position.x, 
                      y:this.ball[this.ball.length-1].position.y, 
                      z:this.ball[this.ball.length-1].position.z-0.03*4
                    }, 
                    {
                      x: 0,
                      y: 0, 
                      z: 0
                    }, 
                    4
                  );
                  this.physics.add.constraints.pointToPoint(this.ball[this.ball.length-1].body,this.brick.body, {
                    // the offset from the center of each object
                    pivotA: { z: -0.1 },
                    pivotB: { z: 0.1  }
                  })

                  this.brick = this.addBrick(
                    {
                      x:this.ball1[this.ball1.length-1].position.x, 
                      y:this.ball1[this.ball1.length-1].position.y, 
                      z:this.ball1[this.ball1.length-1].position.z-0.03*4
                    }, 
                    {
                      x: 0,
                      y: 0, 
                      z: 0
                    }, 
                    4
                  );
                  this.physics.add.constraints.pointToPoint(this.ball1[this.ball1.length-1].body,this.brick.body, {
                    // the offset from the center of each object
                    pivotA: { z: -0.1 },
                    pivotB: { z: 0.1  }
                  })

                  this.brick = this.addBrick(
                    {
                      x:this.ball2[this.ball2.length-1].position.x, 
                      y:this.ball2[this.ball2.length-1].position.y, 
                      z:this.ball2[this.ball2.length-1].position.z-0.03*4
                    }, 
                    {
                      x: 0,
                      y: 0, 
                      z: 0
                    }, 
                    4
                  );
                  this.physics.add.constraints.pointToPoint(this.ball2[this.ball2.length-1].body,this.brick.body, {
                    // the offset from the center of each object
                    pivotA: { z: -0.1 },
                    pivotB: { z: 0.1  }
                  })
                break;
              }
            }
          );
        }


      }

      PhysicsLoader('../lib/ammo/kripken', () => new Project({ gravity: { x: 0, y: 0, z: -9.81 }, scenes: [MainScene], softBodies: true }))
    </script>
  </body>
</html>
