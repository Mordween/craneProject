<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Crane project</title>
    <link rel="stylesheet" href="../css/examples.css?ver=1.0.0" />
    <script src="../js/examples.js?ver=1.1.1"></script>
    <script src="../lib/enable3d/enable3d.framework.0.25.4.min.js"></script>
  </head>

  <body>
    <script>
      const { Project, Scene3D, PhysicsLoader, THREE } = ENABLE3D
      const margin = 0.05

      class MainScene extends Scene3D {
        async create() {
          const { orbitControls } = await this.warpSpeed()
          this.camera.position.set(5, 5, 10)
          orbitControls?.target.set(0, 2.5, 0)
          this.camera.lookAt(0, 2.5, 0)

          // enable physics debugging
          this.physics.debug?.enable()

          // ball
          this.ball = this.physics.add.sphere({ x: 1, y: 2, collisionFlags: 2 })

            // bar
            this.bar = this.add.cylinder({ y: 5, height: 5, radiusTop: 0.1, radiusBottom: 0.1 })
            this.bar.rotateX(Math.PI / 2)
            this.physics.add.existing(this.bar, { collisionFlags: 1, mass: 1 })

        // Rope graphic object
        const ropeNumSegments = 10;
        const ropeLength = 4.5;
        const ropeMass = 3;
        const ropePos = {x:0, y:5, z:0.5}
        

        const segmentLength = ropeLength / ropeNumSegments;
        const ropeGeometry = new THREE.BufferGeometry();
        const ropeMaterial = new THREE.LineBasicMaterial( { color: 0x000000 } );
        const ropePositions = [];
        const ropeIndices = [];

        for ( let i = 0; i < ropeNumSegments + 1; i ++ ) {

            ropePositions.push( ropePos.x, ropePos.y + i * segmentLength, ropePos.z );

        }

        for ( let i = 0; i < ropeNumSegments; i ++ ) {

            ropeIndices.push( i, i + 1 );

        }

        ropeGeometry.setIndex( new THREE.BufferAttribute( new Uint16Array( ropeIndices ), 1 ) );
        ropeGeometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( ropePositions ), 3 ) );
        ropeGeometry.computeBoundingSphere();
        this.rope = new THREE.LineSegments( ropeGeometry, ropeMaterial );
        this.rope.castShadow = true;
        this.rope.receiveShadow = true;
        this.scene.add( this.rope );

        let transformAux1 = new Ammo.btTransform();

        // Rope physic object
        const softBodyHelpers = new Ammo.btSoftBodyHelpers();
        const ropeStart = new Ammo.btVector3( ropePos.x, ropePos.y, ropePos.z );
        const ropeEnd = new Ammo.btVector3( ropePos.x, ropePos.y , ropePos.z );

        const ropeSoftBody = softBodyHelpers.CreateRope(this.physics.physicsWorld.getWorldInfo(), ropeStart, ropeEnd, ropeNumSegments - 1, 0 );

        const sbConfig = ropeSoftBody.get_m_cfg()
        sbConfig.set_viterations(10)
        sbConfig.set_piterations(10)

        ropeSoftBody.setTotalMass(ropeMass, false)
        // @ts-ignore
        Ammo.castObject(ropeSoftBody, Ammo.btCollisionObject).getCollisionShape().setMargin(margin * 3)
        this.physics.physicsWorld.addSoftBody(ropeSoftBody, 1, -1)
        this.rope.userData.physicsBody = ropeSoftBody
        // Disable deactivation
        ropeSoftBody.setActivationState(4)

        //   // Glue the cloth to the bar
        const influence = 1
        ropeSoftBody.appendAnchor(0, this.bar.body.ammo, true, influence)

        let test = 1
        
        // this.rope.geometry.attributes.position.array[2] = 1;
        // console.log(this.rope.geometry.attributes.position.array[test])
        // console.log(this.rope.geometry.attributes.position.array[test += 3])
        // console.log(this.rope.geometry.attributes.position.array[test += 3])
        // console.log(this.rope.geometry.attributes.position.array[test += 3])
        // console.log(this.rope.geometry.attributes.position.array[test += 3])
        // console.log(this.rope.geometry.attributes.position.array[test += 3])
        // console.log(this.rope.geometry.attributes.position.array[test += 3])

        console.log(this.bar)


        }

        update(time) {
          // update ball
          this.ball.position.x -= Math.sin(time) * 0.02
          this.ball.body.needUpdate = true

          this.bar.position.z -= Math.sin(time) * 0.01

        
        //   this.rope.geometry.attributes.position.array[2] -= Math.sin(time) * 0.1
        //   this.rope.geometry.attributes.position.needsUpdate = true

          // update rope
          const softBody = this.rope.userData.physicsBody;
          // @ts-ignore
          const ropePosition = this.rope.geometry.attributes.position.array;
          const numVerts = ropePosition.length / 3;

          const nodes = softBody.get_m_nodes();
          let indexFloat = 0;

          for (let i = 0; i < numVerts-1; i++) {          // numVerts - 1 
            const node = nodes.at(i)
            const nodePos = node.get_m_x()
            ropePosition[indexFloat++] = nodePos.x()
            ropePosition[indexFloat++] = nodePos.y()
            ropePosition[indexFloat++] = nodePos.z()
          }

          this.rope.geometry.computeVertexNormals()
          // @ts-ignore
          this.rope.geometry.attributes.position.needsUpdate = true
          // @ts-ignore
          this.rope.geometry.attributes.normal.needsUpdate = true
        }
      }

      PhysicsLoader('../lib/ammo/kripken', () => new Project({ scenes: [MainScene], softBodies: true }))
    </script>
  </body>
</html>
