<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>SoftBody rope</title>
    <link rel="stylesheet" href="../css/examples.css?ver=1.0.0" />
    <script src="../js/examples.js?ver=1.1.1"></script>
    <script src="../lib/enable3d/enable3d.framework.0.25.4.min.js"></script>
  </head>

  <body>
    <script>
      const { Project, Scene3D, PhysicsLoader, THREE } = ENABLE3D

      const hoistPos =  new THREE.Vector3();
      const ballPos =  new THREE.Vector3();
      const ropePos =  new THREE.Vector3();


      // The rope
      const ropeWidth = 0.001
      const ropeLength = 4
      const ropeNumSegmentsZ = 1
      const ropeNumSegmentsY = 50

      // The hoist
      const hoistHeight = 0.5

      // Ball
      const ballMass = 10;
      const ballRadius = 0.6;


      hoistPos.set(0, 0, 8)
      ropePos.set(hoistPos.x, hoistPos.y, hoistPos.z-hoistHeight)
      ballPos.set( ropePos.x, ropePos.y, ropePos.z - ropeLength-ballRadius );


      const ropeBodyUse = false;    // keep false, true is cursed

      class MainScene extends Scene3D {

        async create() {

          const { orbitControls } = await this.warpSpeed()

          this.camera.position.set(10, 10, 20)
          orbitControls?.target.set(0, 2.5, 0)
          this.camera.lookAt(0, 2.5, 0)

          // enable physics debugging
          this.physics.debug?.enable()

          // world axis 
          const axesHelper = new THREE.AxesHelper( 5 );
          axesHelper.setColors(new THREE.Color(255, 0, 0), new THREE.Color(0, 255, 0), new THREE.Color(0, 0, 255))    // in order to know which axis is the right axis
          this.scene.add( axesHelper );

          
          this.ball = this.physics.add.sphere({x:ballPos.x, y:ballPos.y, z:ballPos.z, radius:ballRadius })
          this.ball.castShadow = true;
          this.ball.receiveShadow = true;

          this.ball.body.setFriction(0.8)         // comment ajouter de la friction avec l'air? 

          // hoist
          this.hoist = this.add.box({ z: hoistPos.z, height: hoistHeight, width : 0.5 })
          this.physics.add.existing(this.hoist, { collisionFlags: 2, mass: 155 })


          const ropeGeometry = new THREE.PlaneGeometry(ropeWidth, ropeLength, ropeNumSegmentsZ, ropeNumSegmentsY)

          const ropeMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff, side: THREE.DoubleSide })
          this.rope = new THREE.Mesh(ropeGeometry, ropeMaterial)
          this.rope.castShadow = true
          this.rope.receiveShadow = true
          this.scene.add(this.rope)

          this.load.texture('/assets/img/grid.png').then(texture => {
            texture.wrapS = THREE.RepeatWrapping
            texture.wrapT = THREE.RepeatWrapping
            texture.repeat.set(ropeNumSegmentsZ, ropeNumSegmentsY)
            // @ts-ignore
            this.rope.material.map = texture
            // @ts-ignore
            this.rope.material.needsUpdate = true
          })

          console.log("thisPhysics", this.physics.physicsWorld.getWorldInfo())
          this.physics.physicsWorld.getWorldInfo().get_m_gravity().setX(0)
          this.physics.physicsWorld.getWorldInfo().get_m_gravity().setY(0)
          this.physics.physicsWorld.getWorldInfo().get_m_gravity().setZ(-9.81)      // FIX soft body Gravity
          
          console.log("thisPhysics", this.physics.physicsWorld.getWorldInfo())

          const softBodyHelpers = new Ammo.btSoftBodyHelpers()
          let ropeSoftBody
          
          if (ropeBodyUse === true)   /*********************************** CreateRope used *********************************/
          {
            const ropeStart = new Ammo.btVector3( ropePos.x, ropePos.y, ropePos.z );
            const ropeEnd = new Ammo.btVector3( ropePos.x, ropePos.y , ropePos.z - ropeLength );
            ropeSoftBody = softBodyHelpers.CreateRope( 
            this.physics.physicsWorld.getWorldInfo(), 
            ropeStart, 
            ropeEnd, 
            ropeNumSegmentsY - 1, 
            0 
            );
          }
          else                      /*********************************** CreatePatch used *********************************/
          {
            const ropeCornerBR = new Ammo.btVector3(ropePos.x, ropePos.y + 0.5 * ropeWidth, ropePos.z - ropeLength)
            const ropeCornerBL = new Ammo.btVector3(ropePos.x, ropePos.y - 0.5 * ropeWidth, ropePos.z - ropeLength)
            const ropeCornerTR = new Ammo.btVector3(ropePos.x, ropePos.y + 0.5 * ropeWidth, ropePos.z)
            const ropeCornerTL = new Ammo.btVector3(ropePos.x, ropePos.y - 0.5 * ropeWidth, ropePos.z)

            ropeSoftBody = softBodyHelpers.CreatePatch(
            this.physics.physicsWorld.getWorldInfo(),
            ropeCornerBR,
            ropeCornerBL,
            ropeCornerTR,
            ropeCornerTL,
            ropeNumSegmentsZ + 1,
            ropeNumSegmentsY + 1,
            0,
            true
            );
          }

          const sbConfig = ropeSoftBody.get_m_cfg()
          sbConfig.set_viterations(100)
          sbConfig.set_piterations(100)       // the rope is no longer elastic

          ropeSoftBody.setTotalMass(0.2, false)                  
          // @ts-ignore
          Ammo.castObject(ropeSoftBody, Ammo.btCollisionObject).getCollisionShape().setMargin(0.04) 
          this.physics.physicsWorld.addSoftBody(ropeSoftBody, 1, -1)

          console.log("this", this)

          this.rope.userData.physicsBody = ropeSoftBody
          
          // Disable deactivation
          ropeSoftBody.setActivationState(4)


          // Glue the rope to the hoist
          const influence = 1

          if(ropeBodyUse == true) /*********************************** if CreateRope used *********************************/
          {
            ropeSoftBody.appendAnchor(0, this.ball.body.ammo, true, influence)
            ropeSoftBody.appendAnchor(ropeNumSegmentsY, this.hoist.body.ammo, false, influence)
          }
          else                    /*********************************** if CreatePatch used *********************************/
          {
            ropeSoftBody.appendAnchor(0, this.ball.body.ammo, true, influence)
            ropeSoftBody.appendAnchor(ropeNumSegmentsY*2, this.hoist.body.ammo, false, influence)
          }

          console.log(ropeSoftBody)
          ropeSoftBody.setFriction(20)
          ropeSoftBody.setRollingFriction(10)


          initInput()
        }

        update(time) {
        
          this.hoist.position.setX(hoistPos.x); this.hoist.position.setY(hoistPos.y); this.hoist.position.setZ(hoistPos.z)
          this.hoist.body.needUpdate = true;

          /*** Friction with air ***/
          this.ball.body.applyForceX(- 0.05* this.ball.body.velocity.x * 0.47 * this.physics.physicsWorld.getWorldInfo().air_density )
          this.ball.body.applyForceY(- 0.05* this.ball.body.velocity.y * 0.47 * this.physics.physicsWorld.getWorldInfo().air_density )
          this.ball.body.applyForceZ(- 0.05* this.ball.body.velocity.z * 0.47 * this.physics.physicsWorld.getWorldInfo().air_density )

        }
      }

      function initInput()
      {
        window.addEventListener(
          "keydown",
          function (event) {
            switch (event.code) {
              case "KeyS":
              case "ArrowDown":
                // Handle "back"
                hoistPos.y -= 0.1;
                break;
              case "KeyW":
              case "ArrowUp":
                // Handle "forward"
                hoistPos.y += 0.1;
                break;
              case "KeyA":
              case "ArrowLeft":
                // Handle "turn left"
                hoistPos.x -= 0.1;
                break;
              case "KeyD":
              case "ArrowRight":
                // Handle "turn right"
                hoistPos.x += 0.1;
                break;
            }
          }
        );
      }

      PhysicsLoader('../lib/ammo/kripken', () => new Project({ gravity: { x: 0, y: 0, z: -9.81 }, scenes: [MainScene], softBodies: true }))
    </script>
  </body>
</html>
