<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>SoftBody rope</title>
    <link rel="stylesheet" href="../css/examples.css?ver=1.0.0" />
    <script src="../js/examples.js?ver=1.1.1"></script>
    <script src="../lib/enable3d/enable3d.framework.0.25.4.min.js"></script>
  </head>

  <body>
    <script>
      const { Project, Scene3D, PhysicsLoader, THREE } = ENABLE3D

      let hoistPos = new THREE.Vector3();
      hoistPos.x = 0;
      hoistPos.y = 0;
      hoistPos.z = 8;
      const ropeBodyUse = false;

      class MainScene extends Scene3D {

        async create() {
          const pos = new THREE.Vector3();
          const quat = new THREE.Quaternion();

          const { orbitControls } = await this.warpSpeed()

          this.camera.position.set(10, 10, 20)
          orbitControls?.target.set(0, 2.5, 0)
          this.camera.lookAt(0, 2.5, 0)

          // enable physics debugging
          this.physics.debug?.enable()

          // world axis 
          const axesHelper = new THREE.AxesHelper( 5 );
          axesHelper.setColors(new THREE.Color(255, 0, 0), new THREE.Color(0, 255, 0), new THREE.Color(0, 0, 255))    // in order to know which axis is the right axis
          this.scene.add( axesHelper );


          // The rope
          const ropeWidth = 0.001
          const ropeHeight = 4
          const hoistHeight = 0.5

          // Ball  2
          const ballMass = 10;
          const ballRadius = 0.6;
          pos.set( -hoistHeight, 0, ropeHeight-ballRadius );
          quat.set( 0, 0, 0, 1 );

          this.ball = this.physics.add.sphere({x:pos.x, y:pos.y, z:pos.z, radius:ballRadius })
          this.ball.castShadow = true;
          this.ball.receiveShadow = true;

          console.log("ball", this.ball)
          this.ball.body.setFriction(0.8)         // comment ajouter de la friction avec l'air? 

          // hoist
          this.hoist = this.add.box({ z: hoistPos.z, height: hoistHeight, width : 0.5 })
          this.physics.add.existing(this.hoist, { collisionFlags: 2, mass: 155 })

          const ropeNumSegmentsZ = 1
          const ropeNumSegmentsY = 50
          const ropePos = new THREE.Vector3(0, 0, 4-hoistHeight)

          const ropeGeometry = new THREE.PlaneGeometry(ropeWidth, ropeHeight, ropeNumSegmentsZ, ropeNumSegmentsY)
          // ropeGeometry.rotateZ(Math.PI)
          // ropeGeometry.translate(ropePos.x, ropePos.y + ropeHeight * 0.5, ropePos.z - ropeWidth * 0.5)

          const ropeMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff, side: THREE.DoubleSide })
          this.rope = new THREE.Mesh(ropeGeometry, ropeMaterial)
          this.rope.castShadow = true
          this.rope.receiveShadow = true
          this.scene.add(this.rope)

          this.load.texture('/assets/img/grid.png').then(texture => {
            texture.wrapS = THREE.RepeatWrapping
            texture.wrapT = THREE.RepeatWrapping
            texture.repeat.set(ropeNumSegmentsZ, ropeNumSegmentsY)
            // @ts-ignore
            this.rope.material.map = texture
            // @ts-ignore
            this.rope.material.needsUpdate = true
          })

          console.log("thisPhysics", this.physics.physicsWorld.getWorldInfo())
          this.physics.physicsWorld.getWorldInfo().get_m_gravity().setX(0)
          this.physics.physicsWorld.getWorldInfo().get_m_gravity().setY(0)
          this.physics.physicsWorld.getWorldInfo().get_m_gravity().setZ(-9.81)      // FIX Gravity fix
          
          console.log("thisPhysics", this.physics.physicsWorld.getWorldInfo())

          const softBodyHelpers = new Ammo.btSoftBodyHelpers()
          let ropeSoftBody
          
          if (ropeBodyUse === true)   /*********************************** CreateRope used *********************************/
          {
            const ropeStart = new Ammo.btVector3( ropePos.x, ropePos.y, ropePos.z );
            const ropeEnd = new Ammo.btVector3( ropePos.x, ropePos.y , ropePos.z + ropeHeight );
            ropeSoftBody = softBodyHelpers.CreateRope( 
            this.physics.physicsWorld.getWorldInfo(), 
            // softBodyWorldInfo,
            ropeStart, 
            ropeEnd, 
            ropeNumSegmentsY - 1, 
            0 
            );
          }
          else                      /*********************************** CreatePatch used *********************************/
          {
            const ropeCorner00 = new Ammo.btVector3(ropePos.x, ropePos.y , ropePos.z + ropeHeight)
            const ropeCorner01 = new Ammo.btVector3(ropePos.x, ropePos.y - ropeWidth, ropePos.z + ropeHeight)
            const ropeCorner10 = new Ammo.btVector3(ropePos.x, ropePos.y, ropePos.z)
            const ropeCorner11 = new Ammo.btVector3(ropePos.x, ropePos.y, ropePos.z - ropeWidth)

            ropeSoftBody = softBodyHelpers.CreatePatch(
            this.physics.physicsWorld.getWorldInfo(),
            // softBodyWorldInfo,
            ropeCorner00,
            ropeCorner01,
            ropeCorner10,
            ropeCorner11,
            ropeNumSegmentsZ + 1,
            ropeNumSegmentsY + 1,
            0,
            true
            );
          }

          const sbConfig = ropeSoftBody.get_m_cfg()
          sbConfig.set_viterations(10)
          sbConfig.set_piterations(10)

          ropeSoftBody.setTotalMass(0.2, false)                                   // masse du soft body
          // @ts-ignore
          Ammo.castObject(ropeSoftBody, Ammo.btCollisionObject).getCollisionShape().setMargin(0.04)     // margin influence la traversé de la code (à travers les rigids bodies)
          this.physics.physicsWorld.addSoftBody(ropeSoftBody, 1, -1)

          console.log("this", this)

          this.rope.userData.physicsBody = ropeSoftBody
          // Disable deactivation
          ropeSoftBody.setActivationState(4)


          // Glue the rope to the hoist
          const influence = 2

          if(ropeBodyUse == true) /*********************************** if CreateRope used *********************************/
          {
            ropeSoftBody.appendAnchor(0, this.ball.body.ammo, true, influence)
            ropeSoftBody.appendAnchor(ropeNumSegmentsY, this.hoist.body.ammo, false, influence)
          }
          else                    /*********************************** if CreatePatch used *********************************/
          {
            ropeSoftBody.appendAnchor(ropeNumSegmentsY*2, this.ball.body.ammo, true, influence)
            ropeSoftBody.appendAnchor(0, this.hoist.body.ammo, false, influence)
          }

          console.log(ropeSoftBody)
          ropeSoftBody.setFriction(20)
          ropeSoftBody.setRollingFriction(10)

          this.value = 0;

          console.log(this.hoist)

          initInput()
        }

        update(time) {
      
          // this.hoist.position.y += Math.sin(time) * 0.01
          // this.hoist.body.needUpdate = true

          /*** Friction with air ***/
          // console.log(this.ball.body.velocity)
          this.hoist.position.setX(hoistPos.x); this.hoist.position.setY(hoistPos.y); this.hoist.position.setZ(hoistPos.z)

          // console.log(hoistPos)
          this.hoist.body.needUpdate = true;
          this.ball.body.applyForceX(- 0.05* this.ball.body.velocity.x * 0.47 * this.physics.physicsWorld.getWorldInfo().air_density )
          this.ball.body.applyForceY(- 0.05* this.ball.body.velocity.y * 0.47 * this.physics.physicsWorld.getWorldInfo().air_density )
          // this.ball.body.applyForceZ(- 0.5* this.ball.body.velocity.z * 0.47 * this.physics.physicsWorld.getWorldInfo().air_density )

          // this.hoist2.position.x -= this.value* 0.001
          // this.hoist2.body.needUpdate = true

          // this.hoist.rotation.set(0, this.value+=0.01,0 )
          // this.hoist.position.set(this.hoist.position.x, this.hoist.position.y, this.hoist.position.z+0.01)

          // this.hoist.body.needUpdate = true

          // this.rope.position.setZ(this.value)

          // if(this.rope.geometry.boundingSphere != undefined)
          // {
          //   console.log(this.rope.geometry.boundingSphere)
          //   this.rope.geometry.boundingSphere.makeEmpty();
          // }

        //   console.log(this.ball.position)
        
            
          // update rope
          // const softBody = this.rope.userData.physicsBody
          // // @ts-ignore
          // const ropePositions = this.rope.geometry.attributes.position.array
          // const numVerts = ropePositions.length / 3

          // const nodes = softBody.get_m_nodes()
          // let indexFloat = 0

          // for (let i = 0; i < numVerts; i++) {
          //   const node = nodes.at(i)
          //   const nodePos = node.get_m_x()
          //   ropePositions[indexFloat++] = nodePos.x()
          //   ropePositions[indexFloat++] = nodePos.y()
          //   ropePositions[indexFloat++] = nodePos.z()
          // }

          // this.rope.geometry.computeVertexNormals()
          // @ts-ignore
          // this.rope.geometry.attributes.position.needsUpdate = true
          // // @ts-ignore
          // this.rope.geometry.attributes.normal.needsUpdate = true
        }
      }

      function initInput()
      {
        window.addEventListener(
          "keydown",
          function (event) {
            switch (event.code) {
              case "KeyS":
              case "ArrowDown":
                // Handle "back"
                hoistPos.y -= 0.1;
                break;
              case "KeyW":
              case "ArrowUp":
                // Handle "forward"
                hoistPos.y += 0.1;
                break;
              case "KeyA":
              case "ArrowLeft":
                // Handle "turn left"
                hoistPos.x -= 0.1;
                break;
              case "KeyD":
              case "ArrowRight":
                // Handle "turn right"
                hoistPos.x += 0.1;
                break;
            }
          }
        );
      }

      PhysicsLoader('../lib/ammo/kripken', () => new Project({ gravity: { x: 0, y: 0, z: -9.81 }, scenes: [MainScene], softBodies: true }))
    </script>
  </body>
</html>
