<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>SoftBody rope</title>
    <link rel="stylesheet" href="../css/examples.css?ver=1.0.0" />
    <script src="../js/examples.js?ver=1.1.1"></script>
    <script src="../lib/enable3d/enable3d.framework.0.25.4.min.Zup.js"></script>
  </head>

  <body>
    <div id="info-text">
      You can move the hoist using the directional arrows or the classic arrow keys.
      You can release the ball and then the rope by pressing the Shift Right key.
      Press the P key to bring the two plates together.
      Or move them apart with the M
      Press Enter to spawn a brick
    </div>
    <script>
      const { Project, Scene3D, PhysicsLoader, THREE, ExtendedObject3D } = ENABLE3D

      const hoistPos =  new THREE.Vector3();
      const ballPos =  new THREE.Vector3();
      const ropePos =  new THREE.Vector3();


      // The rope
      const ropeWidth = 0.001
      const ropeLength = 4
      const ropeNumSegmentsZ = 1
      const ropeNumSegmentsY = 50

      // The hoist
      const hoistHeight = 0.5

      // Ball
      const ballMass = 10;
      const ballRadius = 0.6;


      hoistPos.set(0, 0, 6.5)
      ropePos.set(hoistPos.x, hoistPos.y, hoistPos.z-hoistHeight)
      ballPos.set( ropePos.x, 5+ropePos.y, ropePos.z - ropeLength-ballRadius );


      const ropeBodyUse = false;    // keep false, true is cursed

      let value = Math.PI/4

      class MainScene extends Scene3D {

        async create() {

          const { orbitControls } = await this.warpSpeed()

          this.camera.position.set(10, 10, 20)
          orbitControls?.target.set(0, 2.5, 0)
          this.camera.lookAt(0, 2.5, 0)

          // enable physics debugging
          this.physics.debug?.enable()

          // world axis 
          const axesHelper = new THREE.AxesHelper( 5 );
          axesHelper.setColors(new THREE.Color(255, 0, 0), new THREE.Color(0, 255, 0), new THREE.Color(0, 0, 255))    // in order to know which axis is the right axis
          this.scene.add( axesHelper );

          
          this.ball = this.physics.add.sphere({x:ballPos.x, y:ballPos.y, z:ballPos.z, radius:ballRadius })
          this.ball.castShadow = true;
          this.ball.receiveShadow = true;

          this.ball.body.setFriction(0.8)         // comment ajouter de la friction avec l'air? 

          // hoist
          this.hoist = this.add.box({ z: hoistPos.z, height: hoistHeight, width : 0.5 })
          this.physics.add.existing(this.hoist, { collisionFlags: 2, mass: 155 })


          const ropeGeometry = new THREE.PlaneGeometry(ropeWidth, ropeLength, ropeNumSegmentsZ, ropeNumSegmentsY)

          const ropeMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff, side: THREE.DoubleSide })
          this.rope = new THREE.Mesh(ropeGeometry, ropeMaterial)
          this.rope.castShadow = true
          this.rope.receiveShadow = true
          this.scene.add(this.rope)

          this.load.texture('/assets/img/grid.png').then(texture => {
            texture.wrapS = THREE.RepeatWrapping
            texture.wrapT = THREE.RepeatWrapping
            texture.repeat.set(ropeNumSegmentsZ, ropeNumSegmentsY)
            // @ts-ignore
            this.rope.material.map = texture
            // @ts-ignore
            this.rope.material.needsUpdate = true
          })

          console.log("thisPhysics", this.physics.physicsWorld.getWorldInfo())
          this.physics.physicsWorld.getWorldInfo().get_m_gravity().setX(0)
          this.physics.physicsWorld.getWorldInfo().get_m_gravity().setY(0)
          this.physics.physicsWorld.getWorldInfo().get_m_gravity().setZ(-9.81)      // FIX soft body Gravity
          
          console.log("thisPhysics", this.physics.physicsWorld.getWorldInfo())

          const softBodyHelpers = new Ammo.btSoftBodyHelpers()
          this.ropeSoftBody
          
          if (ropeBodyUse === true)   /*********************************** CreateRope used *********************************/
          {
            const ropeStart = new Ammo.btVector3( ropePos.x, ropePos.y, ropePos.z );
            const ropeEnd = new Ammo.btVector3( ropePos.x, ropePos.y , ropePos.z - ropeLength );
            this.ropeSoftBody = softBodyHelpers.CreateRope( 
            this.physics.physicsWorld.getWorldInfo(), 
            ropeStart, 
            ropeEnd, 
            ropeNumSegmentsY - 1, 
            0 
            );
          }
          else                      /*********************************** CreatePatch used *********************************/
          {
            const ropeCornerBR = new Ammo.btVector3(ropePos.x, ropePos.y + 0.5 * ropeWidth, ropePos.z - ropeLength)
            const ropeCornerBL = new Ammo.btVector3(ropePos.x, ropePos.y - 0.5 * ropeWidth, ropePos.z - ropeLength)
            const ropeCornerTR = new Ammo.btVector3(ropePos.x, ropePos.y + 0.5 * ropeWidth, ropePos.z)
            const ropeCornerTL = new Ammo.btVector3(ropePos.x, ropePos.y - 0.5 * ropeWidth, ropePos.z)

            this.ropeSoftBody = softBodyHelpers.CreatePatch(
            this.physics.physicsWorld.getWorldInfo(),
            ropeCornerBR,
            ropeCornerBL,
            ropeCornerTR,
            ropeCornerTL,
            ropeNumSegmentsZ + 1,
            ropeNumSegmentsY + 1,
            0,
            true
            );
          }

          const sbConfig = this.ropeSoftBody.get_m_cfg()
          sbConfig.set_viterations(100)
          sbConfig.set_piterations(100)       // the rope is no longer elastic

          this.ropeSoftBody.setTotalMass(5, false)                  
          // @ts-ignore
          Ammo.castObject(this.ropeSoftBody, Ammo.btCollisionObject).getCollisionShape().setMargin(0.04) 
          this.physics.physicsWorld.addSoftBody(this.ropeSoftBody, 1, -1)

          console.log("this", this)

          this.rope.userData.physicsBody = this.ropeSoftBody
          
          // Disable deactivation
          this.ropeSoftBody.setActivationState(4)



          
          const armParams = {
            mass: 10,
            z: 2,
            height: 2,
            width: 0.2,
            depth: 2,
            collisionFlags: 2
          }

          const addArm = x => {
            const arm = this.physics.add.box({
              ...armParams,
              x
            })
            arm.body.setFriction(1)
            arm.userData.touched = 0
            arm.body.on.collision((object, event) => {
              if (object.name !== 'heavy_box') return
              arm.userData.touched = event === 'start' || event === 'collision'
            })
            return arm
          }

          // this.leftArm = addArm(-2)
          // this.rightArm = addArm(2)

          this.loadGLBFile('leftGrab', 2, {x:ropePos.x + 0.2, y:ropePos.y, z:ropePos.z-ropeLength}, {x:Math.PI/2, y:Math.PI/4, z:0})
          this.loadGLBFile('rightGrab', 2, {x:ropePos.x -0.2, y:ropePos.y, z:ropePos.z-ropeLength}, {x:Math.PI/2, y:-Math.PI/4, z:Math.PI})

          await new Promise(r => setTimeout(r, 2000));    // wait 2 seconds 

          // Glue the rope to the hoist
          const influence = 1

          if(ropeBodyUse == true) /*********************************** if CreateRope used *********************************/
          {
            this.ropeSoftBody.appendAnchor(ropeNumSegmentsY, this.hoist.body.ammo, false, influence)
            this.ropeSoftBody.appendAnchor(0, this.ball.body.ammo, true, influence)
          }
          else                    /*********************************** if CreatePatch used *********************************/
          {
            this.ropeSoftBody.appendAnchor(ropeNumSegmentsY*2, this.hoist.body.ammo, false, influence)
            // this.ropeSoftBody.appendAnchor(0, this.ball.body.ammo, true, influence)

            // this.ropeSoftBody.appendAnchor(0, this.leftGrab.body.ammo, false, 1)
            // this.ropeSoftBody.appendAnchor(0, this.rightGrab.body.ammo, false, 1)
          }


          console.log(this.ropeSoftBody)
          this.ropeSoftBody.setFriction(20)
          this.ropeSoftBody.setRollingFriction(10)

          // this.createHinge()

          this.brick = this.addBrick({x:0, y:0, z:0}, {x:0, y:0, z:0}, 4)
          this.initInput()
          
          console.log("ropeSoftBody", this.ropeSoftBody.m_nodes.at(0).m_x.x(), this.ropeSoftBody.m_nodes.at(0).m_x.y(), this.ropeSoftBody.m_nodes.at(0).m_x.z())

        }

        update(time) 
        {

          // console.log("ropeSoftBody", this.ropeSoftBody.m_nodes.at(0).m_x.x(), this.ropeSoftBody.m_nodes.at(0).m_x.y(), this.ropeSoftBody.m_nodes.at(0).m_x.z()) // end of the rope
          this.hoist.position.setX(hoistPos.x); this.hoist.position.setY(hoistPos.y); this.hoist.position.setZ(hoistPos.z)
          this.hoist.body.needUpdate = true;

          /*** Friction with air ***/
          this.ball.body.applyForceX(- 0.05* this.ball.body.velocity.x * 0.47 * this.physics.physicsWorld.getWorldInfo().air_density )
          this.ball.body.applyForceY(- 0.05* this.ball.body.velocity.y * 0.47 * this.physics.physicsWorld.getWorldInfo().air_density )
          this.ball.body.applyForceZ(- 0.05* this.ball.body.velocity.z * 0.47 * this.physics.physicsWorld.getWorldInfo().air_density )

          /*** Friction with air ***/
          this.brick.body.applyForceX(- 1* this.ball.body.velocity.x * 0.47 * this.physics.physicsWorld.getWorldInfo().air_density )
          this.brick.body.applyForceY(- 1* this.ball.body.velocity.y * 0.47 * this.physics.physicsWorld.getWorldInfo().air_density )
          this.brick.body.applyForceZ(- 1* this.ball.body.velocity.z * 0.47 * this.physics.physicsWorld.getWorldInfo().air_density )

        }

        loadGLBFile(name, scale, position = {x: number, y: number, z: number}, rotation = {x: number, y: number, z: number})
        {
          this.load.gltf('./object/grab.glb').then(gltf => {

            console.log("first")

            let object = new ExtendedObject3D()
            const mesh = gltf.scene.children[0]
            object.add(mesh)
            object.position.set(position.x, position.y, position.z)
            object.rotation.set(rotation.x, rotation.y, rotation.z)

            object.scale.setX(scale); object.scale.setY(scale); object.scale.setZ(scale);

            object.name = name;

            this[name] = object
            this.add.mesh(this[name])

            this.physics.add.existing(this[name], { collisionFlags: 2, shape: 'mesh', mass : 1})    // mass = 0 => kinematics mesh
            console.log(this)
          });
        }

        createHinge()
        {
          this.grabHinge = this.physics.add.constraints.hinge(this.leftGrab.body, this.rightGrab.body, {
            pivotA: { x: 0, y: 0, z: 0 },
            pivotB: { x: 0, y: 0, z: 0 },
            axisA: { x: 0, y: 1, z: 0},
            axisB: { x: 0, y: -1, z: 0} 
          })
        }

        addBrick = (position = {x: number, y: number, z: number}, rotation = {x: number, y: number, z: number}, scale)=> {
          const brick = this.physics.add.box({
            mass: 10,
            x: position.x,
            y: position.y,
            z: position.z,
            height: 0.22*scale,
            width: 0.105*scale,
            depth: 0.06*scale,
            collisionFlags: 0,
            scale: scale,
          })
          brick.body.setFriction(1)
          return brick
        }

        initInput()
        {
          window.addEventListener(
            "keydown",
            (envent) => {
              switch (event.code) {
                case "KeyS":
                case "ArrowDown":
                  // Handle "back"
                  hoistPos.y -= 0.1;
                  break;
                case "KeyW":
                case "ArrowUp":
                  // Handle "forward"
                  hoistPos.y += 0.1;
                  break;
                case "KeyA":
                case "ArrowLeft":
                  // Handle "turn left"
                  hoistPos.x -= 0.1;
                  break;
                case "KeyD":
                case "ArrowRight":
                  // Handle "turn right"
                  hoistPos.x += 0.1;
                  break;

                case "Shift":
                case "ShiftRight": 
                  // deleate last anchor
                  this.ropeSoftBody.m_anchors.pop_back()
                  break;

                case "p": 
                case "KeyP": 

                  this.leftGrab.rotation.set(Math.PI/2, value+=0.01, 0)
                  this.rightGrab.rotation.set(Math.PI/2, -value, Math.PI)

                  this.leftGrab.body.needUpdate = true
                  this.rightGrab.body.needUpdate = true
                  break;

                case "m": 
                case "Semicolon": 

                  this.leftGrab.rotation.set(Math.PI/2, value-=0.01, 0)
                  this.rightGrab.rotation.set(Math.PI/2, -value, Math.PI)

                  this.leftGrab.body.needUpdate = true
                  this.rightGrab.body.needUpdate = true

                  break;

                case "Enter": 
                  this.brick = this.addBrick(
                    {
                      x:this.ropeSoftBody.m_nodes.at(0).m_x.x(), 
                      y:this.ropeSoftBody.m_nodes.at(0).m_x.y(), 
                      z:this.ropeSoftBody.m_nodes.at(0).m_x.z()+0.03*4
                    }, 
                    {
                      x: 0,
                      y: 0, 
                      z: 0
                    }, 
                    4
                  );
                  this.ropeSoftBody.appendAnchor(0, this.brick.body.ammo, false, 1)
                break;
              }
            }
          );
        }


      }

      PhysicsLoader('../lib/ammo/kripken', () => new Project({ gravity: { x: 0, y: 0, z: -9.81 }, scenes: [MainScene], softBodies: true }))
    </script>
  </body>
</html>
