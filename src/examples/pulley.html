<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Pulley</title>
    <link rel="stylesheet" href="../css/examples.css?ver=1.0.0" />
    <script src="../js/examples.js?ver=1.1.1"></script>
    <script src="../lib/enable3d/enable3d.framework.0.25.4.min.Zup.js"></script>
  </head>

  <body>
    <div id="info-text">
      You can move the pulley using the <b>directional arrows</b> or the <b>classic keys</b>.
      you can wind the rope by pressing <b>+</b> or <b>-</b> <br>
      you can spawn a brick with <b>Enter</b>
    </div>
    <script>
      const { Project, Scene3D, PhysicsLoader, THREE, ExtendedObject3D } = ENABLE3D

      let pulleyRotValue = 0;

      let brickSpawn = false;

      let brickRotZ = 0;
      let brickRotY = 0;
      let brickRotX = 0;

      const pulleyPos =  new THREE.Vector3();
      const ropePos =  new THREE.Vector3();

      // The rope
      const ropeWidth = 0.001
      const ropeLength = 4
      const ropeNumSegmentsZ = 1
      const ropeNumSegmentsY = 50

      // The pulley
      const pulleyRadius = 0.7
      const pulleyHeight = 0.3
      const pulleyScale = 1

      pulleyPos.set(0, 0, 8)
      ropePos.set(pulleyPos.x, pulleyPos.y, pulleyPos.z-pulleyScale*pulleyRadius)

      const ropeBodyUse = false;  
        
      let value = Math.PI/4

      class MainScene extends Scene3D {

        async create() {

          const { orbitControls } = await this.warpSpeed()

          this.camera.position.set(-10, -10, 20)
          orbitControls?.target.set(0, 2.5, 0)
          this.camera.lookAt(0, 0, 0)

          // enable physics debugging
          this.physics.debug?.enable()

          // world axis 
          const axesHelper = new THREE.AxesHelper( 5 );
          axesHelper.setColors(new THREE.Color(255, 0, 0), new THREE.Color(0, 255, 0), new THREE.Color(0, 0, 255))    // in order to know which axis is the right axis
          this.scene.add( axesHelper );


          const pulleyData = [
          {x: 0, y: 0,                      z: 0, height: pulleyHeight  , radiusTop: pulleyRadius, radiusBottom: pulleyRadius },    
          {x: 0, y: (pulleyScale * 4 * pulleyHeight)/6,     z: 0, height: pulleyHeight/3, radiusTop: 1.25*pulleyRadius, radiusBottom: 1.25*pulleyRadius },
          {x: 0, y: - (pulleyScale * 4 * pulleyHeight)/6,   z: 0, height: pulleyHeight/3, radiusTop: 1.25*pulleyRadius, radiusBottom: 1.25*pulleyRadius },
          ]
            let pos = 0
            this.pulley = pulleyData.map(d => {
                let cylinder = this.add.cylinder(d) 
                cylinder.position.x += pulleyPos.x;
                cylinder.position.y += pulleyPos.y;
                cylinder.position.z += pulleyPos.z;
                cylinder.scale.set(pulleyScale, pulleyScale, pulleyScale)
                this.physics.add.existing(cylinder, { shape: 'convex', collisionFlags :(pos === 0?2:2), mass: 10000 })
                pos = 1
                return cylinder
          })
        //   for (let i = 0; i < this.pulley.length - 1; i++) {
        //     const constraint = this.physics.add.constraints.fixed(this.pulley[i].body, this.pulley[i + 1].body)
        //     // [bug] it is not yet possible to choose to "disableCollisionsBetweenLinkedBodies",
        //     // so we remove the constraint add a new one.
        //     this.physics.physicsWorld.removeConstraint(constraint)
        //     this.physics.physicsWorld.addConstraint(constraint, true)
        //   }


          const ropeGeometry = new THREE.PlaneGeometry(ropeWidth, ropeLength, ropeNumSegmentsZ, ropeNumSegmentsY)

          const ropeMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff, side: THREE.DoubleSide })
          this.rope = new THREE.Mesh(ropeGeometry, ropeMaterial)
          this.rope.castShadow = true
          this.rope.receiveShadow = true
          this.scene.add(this.rope)

          this.load.texture('/assets/img/grid.png').then(texture => {
            texture.wrapS = THREE.RepeatWrapping
            texture.wrapT = THREE.RepeatWrapping
            texture.repeat.set(ropeNumSegmentsZ, ropeNumSegmentsY)
            // @ts-ignore
            this.rope.material.map = texture
            // @ts-ignore
            this.rope.material.needsUpdate = true
          })

          console.log("thisPhysics", this.physics.physicsWorld.getWorldInfo())
          this.physics.physicsWorld.getWorldInfo().get_m_gravity().setX(0)
          this.physics.physicsWorld.getWorldInfo().get_m_gravity().setY(0)
          this.physics.physicsWorld.getWorldInfo().get_m_gravity().setZ(-9.81)      // FIX soft body Gravity
          
          console.log("thisPhysics", this.physics.physicsWorld.getWorldInfo())

          const softBodyHelpers = new Ammo.btSoftBodyHelpers()
          this.ropeSoftBody
          
          if (ropeBodyUse === true)   /*********************************** CreateRope used *********************************/
          {
            const ropeStart = new Ammo.btVector3( ropePos.x, ropePos.y, ropePos.z );
            const ropeEnd = new Ammo.btVector3( ropePos.x, ropePos.y , ropePos.z - ropeLength );
            this.ropeSoftBody = softBodyHelpers.CreateRope( 
            this.physics.physicsWorld.getWorldInfo(), 
            ropeStart, 
            ropeEnd, 
            ropeNumSegmentsY - 1, 
            0 
            );
          }
          else                      /*********************************** CreatePatch used *********************************/
          {
            const ropeCornerBR = new Ammo.btVector3(ropePos.x, ropePos.y + 0.5 * ropeWidth, ropePos.z - ropeLength)
            const ropeCornerBL = new Ammo.btVector3(ropePos.x, ropePos.y - 0.5 * ropeWidth, ropePos.z - ropeLength)
            const ropeCornerTR = new Ammo.btVector3(ropePos.x, ropePos.y + 0.5 * ropeWidth, ropePos.z)
            const ropeCornerTL = new Ammo.btVector3(ropePos.x, ropePos.y - 0.5 * ropeWidth, ropePos.z)

            this.ropeSoftBody = softBodyHelpers.CreatePatch(
            this.physics.physicsWorld.getWorldInfo(),
            ropeCornerBR,
            ropeCornerBL,
            ropeCornerTR,
            ropeCornerTL,
            ropeNumSegmentsZ + 1,
            ropeNumSegmentsY + 1,
            0,
            true
            );
          }

          const sbConfig = this.ropeSoftBody.get_m_cfg()
          sbConfig.set_viterations(100)
          sbConfig.set_piterations(100)       // the rope is no longer elastic

          this.ropeSoftBody.setTotalMass(100, false)                  
          // @ts-ignore
          Ammo.castObject(this.ropeSoftBody, Ammo.btCollisionObject).getCollisionShape().setMargin(0.04) 
          this.physics.physicsWorld.addSoftBody(this.ropeSoftBody, 1, -1)

          console.log("this", this)

          this.rope.userData.physicsBody = this.ropeSoftBody
          
          // Disable deactivation
          this.ropeSoftBody.setActivationState(4)

          // Glue the rope to the pulley
          const influence = 1

          if(ropeBodyUse == true) /*********************************** if CreateRope used *********************************/
          {
            this.ropeSoftBody.appendAnchor(0, this.pulley[0].body.ammo, false, influence)
          }
          else                    /*********************************** if CreatePatch used *********************************/
          {
            this.ropeSoftBody.appendAnchor(ropeNumSegmentsY*2, this.pulley[0].body.ammo, false, influence)
          }

          this.ropeSoftBody.setFriction(1)
          this.ropeSoftBody.setRollingFriction(1)

          this.brick = this.addBrick({x:5, y:5, z:5}, {x:0, y:0, z:0}, 4, 2)
          this.initInput()


          const armParams = {
            mass: 1,
            z: 2,
            height: 0.7,
            width: 0.1,
            depth: 0.4,
            collisionFlags: 2
          }
          const addArm = x => {
            const arm = this.physics.add.box({
              ...armParams,
              x
            })
            arm.body.setFriction(1)
            arm.body.setDamping(0.5,0.5);
            return arm
          }
          this.leftArm = addArm(-0.3)
          this.rightArm = addArm(0.3)

        }

        update(time) 
        {

          for (let i = 0; i < this.pulley.length; i++) {
              this.pulley[i].rotation.y = pulleyRotValue;
              this.pulley[i].position.setX(pulleyPos.x); 
              this.pulley[i].position.setY(i === 0 ? pulleyPos.y : (i===1? pulleyPos.y + 4 * pulleyHeight/6:pulleyPos.y - 4 * pulleyHeight/6)); 
              this.pulley[i].position.setZ(pulleyPos.z);
              this.pulley[i].body.needUpdate = true
          }

          // this.brick.rotation.z = brickRotZ
          // this.brick.rotation.y = brickRotY
          // this.brick.rotation.x = brickRotX
          // this.brick.body.needUpdate = true
          if (brickSpawn===true)
           { 
            this.leftArm.position.set(  this.brick.position.x,
                                        this.brick.position.y,
                                        this.brick.position.z 
                                      )
            this.leftArm.translateX(0.4)

            this.rightArm.position.set( this.brick.position.x,
                                        this.brick.position.y,
                                        this.brick.position.z 
                                      )
            this.rightArm.translateX(-0.4)

            this.leftArm.quaternion._w = this.brick.quaternion.w 
            this.leftArm.quaternion._x = this.brick.quaternion.x
            this.leftArm.quaternion._y = this.brick.quaternion.y
            this.leftArm.quaternion._z = this.brick.quaternion.z

            this.rightArm.quaternion._w = this.brick.quaternion.w 
            this.rightArm.quaternion._x = this.brick.quaternion.x
            this.rightArm.quaternion._y = this.brick.quaternion.y
            this.rightArm.quaternion._z = this.brick.quaternion.z

            this.leftArm.body.needUpdate = true
            this.rightArm.body.needUpdate = true
          }

            // console.log(this.brick.rotation)
            // console.log(this.brick.quaternion)
          // /*** Friction with air ***/ 
          // this.brick.body.applyForceX(- 0.05* this.brick.body.velocity.x * 1 * this.physics.physicsWorld.getWorldInfo().air_density )
          // this.brick.body.applyForceY(- 0.05* this.brick.body.velocity.y * 1 * this.physics.physicsWorld.getWorldInfo().air_density )
          // this.brick.body.applyForceZ(- 0.05* this.brick.body.velocity.z * 1 * this.physics.physicsWorld.getWorldInfo().air_density )

        }

        addBrick = (position = {x: number, y: number, z: number}, rotation = {x: number, y: number, z: number}, scale, collisionFlags)=> {
          const brick = this.physics.add.box({
            mass: 10,
            x: position.x,
            y: position.y,
            z: position.z,
            height: 0.22*scale,
            width: 0.105*scale,
            depth: 0.06*scale,
            collisionFlags: collisionFlags,
            scale: scale,
          })
          brick.body.setFriction(1)
          brick.body.setDamping(0.5,0.5);
          return brick
        }

        initInput()
        {
          window.addEventListener(
            "keydown",
            (event) => {
              switch (event.code) {
                case "KeyS":
                    brickRotX -= 0.01;
                    break;
                case "ArrowDown":
                  // Handle "back"
                  pulleyPos.y -= 0.1;
                  break;
                case "KeyW":
                    brickRotX += 0.01;
                    break;
                case "ArrowUp":
                  // Handle "forward"
                  pulleyPos.y += 0.1;
                  break;
                case "KeyA":
                    brickRotY -= 0.01;
                    break;
                case "ArrowLeft":
                  // Handle "turn left"
                  pulleyPos.x -= 0.1;
                  break;
                case "KeyD":
                    brickRotY += 0.01;
                    break;
                case "ArrowRight":
                  // Handle "turn right"
                  pulleyPos.x += 0.1;
                  break;

                case "Shift":
                case "ShiftRight": 
                  // deleate last anchor
                  this.ropeSoftBody.m_anchors.pop_back()
                  break;


                case "Enter": 
                  this.brick = this.addBrick(
                    {
                      x:this.ropeSoftBody.m_nodes.at((ropeBodyUse === true ) ? ropeNumSegmentsY : 0).m_x.x(), 
                      y:this.ropeSoftBody.m_nodes.at((ropeBodyUse === true ) ? ropeNumSegmentsY : 0).m_x.y(), 
                      z:this.ropeSoftBody.m_nodes.at((ropeBodyUse === true ) ? ropeNumSegmentsY : 0).m_x.z()-0.03*4
                    }, 
                    {
                      x: 5,
                      y: 2, 
                      z: 1
                    }, 
                    4,
                    0
                  );
                  console.log(this.brick.rotation)
                  brickSpawn = true;
                  this.ropeSoftBody.appendAnchor((ropeBodyUse === true ) ? ropeNumSegmentsY : 0, this.brick.body.ammo, false, 1)
                break;

                case "+":
                case "NumpadAdd":
                    pulleyRotValue += 0.01
                    brickRotZ +=0.01
                  
                break;

                case "-":
                case "NumpadSubtract":
                    pulleyRotValue -= 0.01
                    brickRotZ -=0.01
                  
                break;
              }
            }
          );
        }


      }

      PhysicsLoader('../lib/ammo/kripken', () => new Project({ gravity: { x: 0, y: 0, z: -9.81 }, scenes: [MainScene], softBodies: true }))
    </script>
  </body>
</html>
